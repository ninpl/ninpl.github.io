<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Aprende C# con Unity - Enums y Flags&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.51" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
</head>

<body>
	<header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
		</h1>
	</div>
	<nav class="site-nav">

		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="BackDoor">
  		</i>&nbsp; BackDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="Public">
  		</i>&nbsp; Publico</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="About">
  		</i>&nbsp; About</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="">
		<i class="fa fa-fw fa-home"></i>
	</a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/index.xml" title="Subscribirte">
		<i class="fa fa-fw fa-rss"></i>
	</a>
</li>

<li class="icon">
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>



<li class="icon">
	<a href="https://bitbucket.org/MoonAntonio" title="Bitbucket">
		<i class="fa fa-fw fa-bitbucket"></i>
	</a>
</li>







<li class="icon">
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li class="icon">
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>

<li class="icon">
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>


		</ul>
	</nav>
</header>


	<div class="content">
	<article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/img103.png')">
			<h1 class="title">Aprende C# con Unity - Enums y Flags</h1>
		</header>

		<section class="post-content">
			

<p>Mencionamos brevemente los enums en nuestra última lección, por lo que sentí que ahora sería un buen momento para tratarla en mayor profundidad. Al mismo tiempo, podemos ampliar el tema e introducir Flags (máscaras de bits). Algo de esto se profundiza en el lado nerd de la programación, pero intentaré que todo sea fácil de entender.</p>

<p><center><a href="https://github.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-github-alt"></i>GitHub Repo</a><a href="https://gitlab.com/CodeBackDoor/LearnCSharpUnity" class="button"><i class="fa fa-gitlab"></i>GitLab Repo</a></center></p>

<h1 id="el-tipo-enum">El tipo &ldquo;Enum&rdquo;</h1>

<p>Primero introduje la enumeración en la lección anterior con la configuración de &ldquo;Difficulties&rdquo;:</p>

<hr />

<pre><code class="language-C#">public enum Difficulties
{
  Easy,
  Medium,
  Hard,
  Count
}
</code></pre>

<hr />

<p>Este fragmento de código se puede colocar fuera de una clase y se convierte en un tipo &ldquo;global&rdquo; que puede ser utilizado por cualquiera de sus scripts. También puede ubicarlo dentro de una clase, pero luego para acceder a él, necesita hacer referencia a la enumeración a través de puntos.</p>

<hr />

<pre><code class="language-C#">// Este ejemplo se puede usar cuando Difficulties no está contenido en una clase
// o cuando está definido en la clase actual
Difficulties d1 = Difficulties.Easy;
// Este ejemplo se usa cuando se define Difficulties en una clase
// que no sea la clase actual
Demo.Difficulties d2 = Demo.Difficulties.Easy;
</code></pre>

<hr />

<p>El tipo enum es único para sí mismo, aunque tiene un tipo subyacente (por defecto, &lsquo;int&rsquo;). Es posible cambiar el tipo subyacente en la declaración, como especificar el &ldquo;byte&rdquo;, lo que podría hacer si sabe que no tendrá un gran rango de valores que deben representarse. El formulario se ve bastante similar a la herencia de clase, donde se hace referencia al tipo subyacente después de dos puntos, como en el siguiente ejemplo:</p>

<hr />

<pre><code class="language-C#">public enum Difficulties : byte
{
  Easy,
  Medium,
  Hard,
  Count
}
</code></pre>

<hr />

<p>La instancia de una clase, puede asignarla a una referencia de tipo &ldquo;base&rdquo; sin conversión. Esto no es así con las enumeraciones; en su lugar, debe convertirlo o, de lo contrario, verá un error: &ldquo;error CS0266: no se puede convertir implícitamente el tipo Demo.Difficulties &lsquo;en byte&rsquo;. Existe una conversión explícita (¿falta using?) &ldquo;</p>

<hr />

<pre><code class="language-C#">void Start ()
{
  // La conversión implícita de una instancia al tipo base está bien
  MonoBehaviour script = this;
  // La conversión implícita de una enumeración a un tipo subyacente no está bien...
  // byte value = Difficulties.Easy;
  // ... Usa esto en cambio
  byte value = (byte)Difficulties.Easy;
}
</code></pre>

<hr />

<p>Los valores en nuestra enum comienzan con el valor predeterminado del tipo subyacente (&lsquo;0&rsquo;) y cuentan hacia arriba, aunque puede especificar cualquier valor que el tipo subyacente pueda contener. Dejados solos, nuestros valores de Difficulties variarían de 0 a 3. Para especificar valores, use la siguiente forma:</p>

<hr />

<pre><code class="language-C#">public enum Multipliers
{
  Negative = -1,
  Nullify = 0,
  Positive = 1
}
</code></pre>

<hr />

<p>Tenga en cuenta que debido a que los valores se autoincrementan, también podría haber especificado el valor &ldquo;Negativo&rdquo; y las otras entradas se habrían asignado correctamente.</p>

<h1 id="bits-y-cambio-de-bit">Bits y cambio de bit</h1>

<p>Uno de los mejores usos de las enumeraciones viene por medio de su uso como máscara de bits. Sin embargo, antes de comenzar a cubrir eso, puede ser útil tener una comprensión general de lo que está sucediendo bajo el capó.</p>

<p>Los bits se refieren a la secuencia binaria de 0 y 1 que, en conjunto, se utilizan para definir cosas más complejas. Los tipos de datos requieren una cierta cantidad de bits para estar completamente representados. Un &lsquo;byte&rsquo;, por ejemplo, requiere 8 bits como los siguientes:00000000</p>

<p>El valor numérico de la muestra anterior era cero, y al encender (establecer bits a 1 en varias ubicaciones) obtiene combinaciones que hacen los otros números. Aquí hay algunos números en orden con su patrón de bits asociado:</p>

<hr />

<pre><code class="language-C#">00000000 = 0
00000001 = 1
00000010 = 2
00000011 = 3
00000100 = 4
</code></pre>

<hr />

<p>Es de esperar que pueda ver el patrón aquí, donde se incrementa a uno, luego mover un lugar y restablecer el otro bit a 0 para continuar incrementando el valor numérico.</p>

<p>Algunos programadores analizan esto y piensan: &ldquo;Podría usar esta secuencia de bits como una matriz de bool&rdquo;, y sin necesitar la cantidad equivalente de almacenamiento (tenga en cuenta que un &ldquo;bool&rdquo; requiere 8 bits). Básicamente, están mirando cada posición de bit y diciendo: ¿este bit es 0 (falso) o 1 (verdadero)?</p>

<p>Algunas matemáticas simples pueden revelar la posición de cada bit: 2 a la potencia del índice del bit que desea establecer, recuerde comenzar a contar desde cero:</p>

<hr />

<pre><code class="language-C#">00000001 = 2 ^ 0 = 1
00000010 = 2 ^ 1 = 2
00000100 = 2 ^ 2 = 4
00001000 = 2 ^ 3 = 8
</code></pre>

<hr />

<p>Pero si no quiere recordar las matemáticas, puede usar algo llamado cambio de bit. Utilizará &ldquo;&lt;&lt;&rdquo; para desplazarse un poco hacia la izquierda. Usaremos este método para declarar los valores de enum flags en un momento:</p>

<hr />

<pre><code class="language-C#">00000001 = 1 &lt;&lt; 0
00000010 = 1 &lt;&lt; 1
00000100 = 1 &lt;&lt; 2
00001000 = 1 &lt;&lt; 3
</code></pre>

<hr />

<h1 id="flags-máscara-de-bits">Flags (máscara de bits)</h1>

<p>A veces verá una enumeración marcada con &ldquo;Flags&rdquo; como se muestra a continuación:</p>

<hr />

<pre><code class="language-C#">[System.Flags]
public enum Colors
{
  None = 0,
  Red = 1 &lt;&lt; 0,
  Green = 1 &lt;&lt; 1,
  Blue = 1 &lt;&lt; 2
}
</code></pre>

<hr />

<p>El marcador no tiene ningún efecto en la enumeración en sí o en los valores predeterminados que están asignados a sus elementos. Tenga en cuenta que aún tuve que asignar manualmente la potencia de 2 valores. Debajo del capó, este enum de &lsquo;Colores&rsquo; todavía tiene un tipo subyacente de &lsquo;int&rsquo; y puede contener cualquier valor que pueda tener &lsquo;int&rsquo; y puede tener sus elementos asignados a cualquier valor dentro de ese rango, tal como lo podría haber hecho sin usar el marcador &lsquo;Flags&rsquo;. La razón por la que utiliza el marcador es habilitar otras funcionalidades, como la modificación de la salida, ToString() que pueden mostrar los nombres de los indicadores combinados en lugar del equivalente numérico del tipo subyacente.</p>

<p>Como definí cada elemento como una potencia de dos, esta enumeración puede tratarse como una &ldquo;máscara de bits&rdquo;, lo que significa que puede especificar cualquier combinación de los elementos (y activarlos o desactivarlos fácilmente en cualquier momento), en lugar de señalar solo a un solo elemento a la vez.</p>

<p>Varias características que deseará con frecuencia se muestran en el siguiente código:</p>

<hr />

<pre><code class="language-C#">void Start ()
{
  // Crea una variable para contener nuestra máscara de bits
  Colors c = Colors.None;
  // Activar
  c |= Colors.Red;
  // O asignar directamente una combinación de bits
  c = Colors.Blue | Colors.Green;  // Esto también se puede usar en la definición de nuevos elementos dentro del tipo enum mismo
  // Apagar
  c &amp;= ~Colors.Blue;
  // Verifica si un bit está 'encendido'
  if ((c &amp; Colors.Green) == Colors.Green)
  {
    // La flag está 'encendida'
  }
}
</code></pre>

<hr />

<p>Algo de esto parece un poco difícil de leer, así que lo explicaré ahora. La línea vertical &lsquo;|&rsquo; se lee &lsquo;O&rsquo;, lo que significa que está modificando la secuencia de bits para que esté &lsquo;activada&rsquo; en cualquier ubicación en la que los otros bits de los números hayan estado &lsquo;activados&rsquo;.</p>

<p>Entonces, por ejemplo, esta línea c = Colors.Blue | Colors.Green; mira las dos secuencias de bits para hacer una secuencia de tercer bit donde cualquier bit que era un &lsquo;1&rsquo; de cualquier valor será un &lsquo;1&rsquo; en la salida final:</p>

<hr />

<pre><code class="language-C#">00000010 - Green
00000100 - Blue
-------- // Realice una OR para que se pase uno en cualquier columna
00000110 - Green, Blue
</code></pre>

<hr />

<p>El &lsquo;&amp;&rsquo; se lee &lsquo;AND&rsquo;, pero es muy diferente de &lsquo;OR&rsquo; porque requiere que se habilite el mismo bit (index-wise) en ambos números para que también se habilite el resultado final. Dado que Verde y Azul tienen índices diferentes, el uso de &lsquo;AND&rsquo; en ellos daría como resultado cero, o &lsquo;Colors.None&rsquo;.</p>

<p>El &lsquo;~&rsquo; se lee &lsquo;NO&rsquo; y se refiere a una secuencia de bits que es opuesta a la secuencia actual (cada 0 se convierte en 1 y viceversa). Usamos una combinación de &lsquo;Y&rsquo; y &lsquo;NO&rsquo; para eliminar una flag, que funciona así:</p>

<hr />

<pre><code class="language-C#">00000110 - Verde, azul // Nuestro valor inicial tiene dos indicadores habilitados
11111011 - Esto es NO azul
-------- // Realizar un AND en estas dos secuencias deja solo los bits que están habilitados
00000010 - Volver a solo verde
</code></pre>

<hr />

<h1 id="bitmasks-y-unity">BitMasks y Unity</h1>

<p>Unity puede serializar su enumeración, desafortunadamente, no proporciona automáticamente un inspector de tipo selección de máscara por defecto. Obtendrá una buena lista desplegable con nombre para seleccionar una sola entrada a la vez, pero no la capacidad de seleccionar múltiples entradas como lo haría con una máscara de eliminación de la cámara como un ejemplo. Sin embargo, puede escribir un inspector personalizado para su script y exponer una propiedad usando EnumMaskField para obtener la funcionalidad que desea.</p>

<p>Por ejemplo, su script &ldquo;EnumsFlags.cs&rdquo;:</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
	[System.Flags]
	public enum Colors
	{
		None = 0,
		Red = 1 &lt;&lt; 0,
		Green = 1 &lt;&lt; 1,
		Blue = 1 &lt;&lt; 2,
	}

	public class EnumsFlags : MonoBehaviour 
	{
		public Colors color;
	}
}
</code></pre>

<hr />

<p>Se puede combinar con un script de inspector especial &ldquo;EnumsFlagsInspector.cs&rdquo; (Tenga en cuenta que este script debe estar ubicado dentro de una carpeta llamada &ldquo;Editor&rdquo; para funcionar):</p>

<hr />

<pre><code class="language-C#">#region Librerias
using UnityEngine;
using UnityEditor;
using System.Collections;
#endregion

namespace MoonAntonio
{
	[CustomEditor(typeof(EnumsFlags))]
	public class EnumsFlagsInspector : Editor
	{
		public override void OnInspectorGUI()
		{
			EnumsFlags e = (EnumsFlags)target;
			e.color = (Colors)EditorGUILayout.EnumFlagsField(&quot;Colors&quot;, e.color);
		}
	}
}
</code></pre>

<hr />

<p><center><img src="/img/codebackdoor/learncsharpunity/11.gif" alt="010" /></center></p>

<h1 id="resumen">Resumen</h1>

<p>En esta lección, cubrí las enumeraciones y sus usos, incluido el uso como máscaras de bits. Tomamos una vista en profundidad de cómo se representan los bits y cubrimos escenarios de uso común, como encender y apagar bits o verificar el estado de un bit. Algunas de estas características no son tan &ldquo;legibles&rdquo; como otras opciones de codificación, pero generalmente son más eficientes, por lo que tiene sentido usarlas en ciertos escenarios. Finalmente, mostramos cómo Unity puede usar una máscara de bits en el editor escribiendo un script editor personalizado.</p>

<p><center><a href="http://bit.ly/2BPN0t6" class="button">Siguiente - Structs</a></p>


			

			
				<hr>
				

<h3>Relacionado</h3>
<ul>
	
	<li><a href="/post/2018/csharpunity/009/">Aprende C# con Unity - Guardando datos</a></li>
	
	<li><a href="/post/2018/csharpunity/008/">Aprende C# con Unity - Clases</a></li>
	
	<li><a href="/post/2018/csharpunity/007/">Aprende C# con Unity - Corrutinas</a></li>
	
	<li><a href="/post/2018/csharpunity/006/">Aprende C# con Unity - Genéricos</a></li>
	
	<li><a href="/post/2018/csharpunity/005/">Aprende C# con Unity - Bucles</a></li>
	
</ul>

			
		</section>
	</article>
	</div>

	<footer class="site-footer">
	<p class="text">&copy; 2018 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-89564434-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
