<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Conceptos Generacion&middot; Antonio Moon´s</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="Moon Antonio">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Antonio,Dev,Game">
	<meta name="generator" content="Hugo 0.55.4" />

	<!-- CSS -->
	<link rel="stylesheet" href="https://moonantonio.github.io/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://moonantonio.github.io/favicon.ico" type="image/x-icon">

	

	<!-- Font Awesome -->
	<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
</head>

<body>
	<header class="site-header">
	<div class="branding">
		<a href="https://moonantonio.github.io/">
		<img class="avatar" src="https://moonantonio.github.io/img/avatar.png" alt="avatar"/>
		</a>
		<h1 class="site-title">
			<a href="https://moonantonio.github.io/">Antonio Moon´s</a>
		</h1>
	</div>
	<nav class="site-nav">

		<ul>
			<li><a href="/about/">  </a></li>

			<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/tags/devblog/" title="devBlog">
  		</i>&nbsp; devBlog</a> <i class="fa fa-gamepad" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/backdoor" title="BackDoor">
  		</i>&nbsp; BackDoor</a> <i class="fa fa-black-tie" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://github.com/MoonAntonio/rec.repos" title="Public">
  		</i>&nbsp; Publico</a> <i class="fa fa-code" aria-hidden="true"></i>
  </a>
</li>

<li class="list-group">
  <a class="list-group-item" href="https://moonantonio.github.io/portfolio/" title="About">
  		</i>&nbsp; About</a> <i class="fa fa-terminal" aria-hidden="true"></i>
  </a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="&#43;">
		</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
	</a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/" title="">
		<i class="fa fa-fw fa-home"></i>
	</a>
</li>

<li class="icon">
	<a href="https://moonantonio.github.io/index.xml" title="Subscribirte">
		<i class="fa fa-fw fa-rss"></i>
	</a>
</li>

<li class="icon">
	<a href="mailto:antoniomt.moon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>



<li class="icon">
	<a href="https://bitbucket.org/MoonAntonio" title="Bitbucket">
		<i class="fa fa-fw fa-bitbucket"></i>
	</a>
</li>







<li class="icon">
	<a href="https://github.com/MoonAntonio" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























<li class="icon">
	<a href="https://trello.com/antoniomoon" title="Trello">
		<i class="fa fa-fw fa-trello"></i>
	</a>
</li>

<li class="icon">
	<a href="https://gitlab.com/MoonAntonio" title="Gitlab">
		<i class="fa fa-fw fa-gitlab"></i>
	</a>
</li>


		</ul>
	</nav>
</header>


	<div class="content">
	<article class="feature-image">
		<header style="background-image: url('https://moonantonio.github.io/img/bg.png')">
			<h1 class="title">Conceptos Generacion</h1>
		</header>

		<section class="post-content">
			

<h1 id="generacion-de-contenido-procedural-basico">Generacion de contenido procedural - Basico</h1>

<hr />

<h3 id="qué-es-el-pcg">¿Qué es el PCG?</h3>

<p>Aquí debo comenzar diciendo que en realidad una definición certera y aceptada por toda la academia no existe, es por eso que voy a mencionar diversas definiciones que obtuve de las referencias en las que me base:</p>

<ul>
<li>El PCG es la creación algorítmica de contenido de un juego, con entrada de información limitada o indirecta por parte del usuario.</li>
<li>El PCG es la generación programática de contenido de un juego, utilizando un proceso aleatorio o pseudo aleatorio que da como resultado un rango impredecible de posibles espacios de juego.</li>
<li>El PCG es el concepto o paradigma por el cual todas las piezas de contenido de un juego pueden ser creadas solo mediante la utilización de la programación.</li>
</ul>

<p>En otras palabras, el PCG es la creación de contenido de un juego mediante la programación. Y para comprender mejor esto, debo explicar su nombre. La palabra clave <strong>Procedural</strong>, viene de procedimiento, que en la programación es simplemente una instrucción que debe ser ejecutada. Por supuesto los procedimientos (también conocidos como funciones y métodos) son el principal paradigma en la programación. Por otra parte el <strong>Content</strong> o contenido es todo lo que se presenta ante el usuario, es decir, niveles, modelos, texturas, música, sonidos, historias, inteligencia artificial, entre otras tantas.</p>

<p><center><img src="/img/case/proce001.png" alt="001" /></center>
<center><em>A la izquierda se puede observar una textura hecha a mano, y a la derecha una textura generada de manera procedimental</em></center></p>

<hr />

<h3 id="por-qué-deberíamos-utilizar-el-pcg">¿Por qué deberíamos utilizar el PCG?</h3>

<p>Tal vez la respuesta a esta pregunta sea obvia, pero de igual manera es importante analizarla. Por supuesto la razón primordial para utilizar PCG es que nos quita la necesidad (casi en su totalidad) de contar con un diseñador o artista humano que genere contenido para el juego. Sabemos que los humanos somos lentos y costosos y por lo general se necesita cada vez más de ellos para crear contenido de alta calidad para los videojuegos de la industria. Pero si utilizamos el PCG como la roca fundamental sobre la que edificamos el videojuego, nos estaremos ahorrando varios hombres, que podrían haber diseñado o creado contenido de manera manual y no automática y eficiente como lo hacen los algoritmos.  Se dice que las ventajas de utilizar el PCG son la unicidad, la robustez, la flexibilidad, la adaptabilidad que aportan al videojuego. Sobre todo ya que podríamos hacer un juego rejugable casi de manera infinita (como veremos más adelante al implementar algoritmos). Un claro ejemplo de esto es el sistema de generación de armas del famoso videojuego Borderlands que se puede apreciar en la imagen.</p>

<p><center><img src="/img/case/proce002.png" alt="002" /></center>
<center><em>Generación procedimental de armas en Bordelands de Gearbox Software</em></center></p>

<hr />

<h2 id="teoría-fundamental">Teoría Fundamental</h2>

<h3 id="números-pseudo-aleatorios">Números Pseudo Aleatorios</h3>

<p>Los números aleatorios han sido utilizados en una gran cantidad de juegos desde hace mucho tiempo, desde juegos tradicionales como lo son los juegos de cartas hasta los juegos de mesa con dados. Los números aleatorios entregan al juego un factor que los hace impredecibles. Y sabemos que las cosas impredecibles son emocionantes, desafiantes y ofrecen una experiencia única, por lo tanto entregan un valor único a un universo.</p>

<p>En las ciencias de la computación el estudio de los números aleatorios se ha enfocado por lo general en su uso en la criptografía y la ciber seguridad, por supuesto mediante complejos algoritmos y fórmulas matemáticas, que aquí no serán estudiadas para su alivio. Unity de hecho ya provee una clase llamada Random, la que permite generar números aleatorios, como veremos más adelante.</p>

<hr />

<h3 id="números-aleatorios-vs-números-pseudo-aleatorios">Números Aleatorios VS Números Pseudo Aleatorios</h3>

<p>Y aquí viene la cruda realidad nuevamente a recordarnos porque somos imperfectos. Han de saber queridos lectores que los números pseudo aleatorios tal como su nombre lo predicen, no son números aleatorios. Un evento realmente aleatorio sería por ejemplo lanzar un dado. Pero por otra parte los números pseudo aleatorios son preferidos en la programación de juegos ya que son mucho más sencillos de generar y por supuesto también de reproducir los mismos resultados una y otra vez (ya les explico por qué). Imaginen si lanzamos un dado de 6 caras y nos sale 1 en la cara, luego si lo lanzamos nuevamente y queremos reproducir el mismo resultado tenemos una probabilidad de <sup>1</sup>&frasl;<sub>6</sub> que el dado nos entregue el mismo resultado, ahora piensen en un dado de 1 millón de caras, si lanzamos y nos sale el número 424.342 en la cara del dado, entonces para poder reproducir el mismo resultado tendríamos <sup>1</sup>&frasl;<sub>1</sub>.000.000 como probabilidad de que nos salga el mismo resultado, lo que significaría para nosotros gran inversión de tiempo seguramente, ¿ya ven por qué utilizar números pseudo aleatorios nos conviene más?</p>

<p>En los números pseudo aleatorios existe algo conocido como <strong>Seed o Semilla</strong> que no es más que la representación (en número, o string) de la aleatoriedad que usara nuestro generador de números pseudo aleatorios y la cual nos será de vital importancia a la hora de replicar un resultado o secuencia de acciones. Por ejemplo si generamos un nivel basados en un seed con el número 5 con X algoritmo, luego podemos replicarlo fácilmente al hacer que el seed simplemente tenga el mismo valor que antes. Pero por otra parte la desventaja que esto entrega es que puede darse el caso en que las combinaciones de reglas posibles de nuestro algoritmo se acaben y luego de un tiempo nuestra seed replique los mismos resultados antes vistos, pero en la mayoría de los casos eso será controlado fácilmente.</p>

<hr />

<h2 id="programando">Programando</h2>

<p>A continuación voy a presentar al lector 2 ejemplos que creo son indicados para poder comenzar a entender de manera práctica esta temática tan apasionante. El primero de ellos se trata de un programa que genera el típico “Hola Mundo”, pero esta vez ordenado de manera procedimental, si bien es cierto este es un ejercicio muy pequeño y sencillo, nos servirá para afirmar los conceptos anteriormente estudiados y aprendidos. Luego en un segundo ejemplo mucho más desafiante que el primero, explicaré paso a paso como crear la estructura de una cueva utilizando el PCG, por supuesto este algoritmo será mucho más complejo (aunque no imposible de entender) que el primero.</p>

<h3 id="unity3d">Unity3D</h3>

<p>Bien conocido es el típico programa que la mayoría de nosotros, cuando dábamos nuestros primeros pasos en la programación, creamos en nuestra primera aventura con una IDE, y con la que logramos un resultado que a pesar de ser sencillo, nos permitió vislumbrar todo el potencial que tienen los computadores para seguir instrucciones de manera ordenada. Bueno tomando esto en cuenta quise esta vez llevarlo al plano de los algoritmos procedimentales, aunque no lo considero precisamente 100% apegado a la definición que vimos antes, pero si nos dará una primera impresión de lo que les venía hablando sobre los universos que pueden ser creados por un computador. Lo que se deseamos lograr como objetivo principal con este pequeño ejemplo, es que podamos generar todas las combinaciones posibles de las letras de las palabras “PROCEDURAL”, por supuesto cada vez que el seed tome un valor determinado, la combinación de letras debería ser distinta, considerando claro que tenemos 10 letras, entonces la cantidad total de combinaciones posibles para mezclar esas letras sería por fórmula 10! que es mas de 362.880 combinaciones. Por lo tanto nuestra seed puede dar un resultado distinto 362.880 veces o mas, y luego de eso, tal y como estudiamos anteriormente se comenzarán a repetir los resultados.</p>

<p><a href="https://github.com/MoonAntonio/pcg">Aqui os dejo el link a GitHub con los diferentes ejemplos.</a></p>

<p>Sin más preámbulos vamos a analizar el siguiente trozo de código que nos permite generar de manera procedural las combinaciones de letras de las palabras “PROCEDURAL”.</p>

<hr />

<pre><code>//                                  ┌∩┐(◣_◢)┌∩┐
//                                                                              \\
// PruebaPCG.cs (26/09/2017)                                                    \\
// Autor: Antonio Mateo (Moon Antonio)  antoniomt.moon@gmail.com                \\
// Descripcion:     Prueba de PCG                                               \\
// Fecha Mod:       26/09/2017                                                  \\
// Ultima Mod:      Version Inicial                                             \\
//******************************************************************************\\

#region Librerias
using UnityEngine;
using System.Collections.Generic;
#endregion

namespace MoonAntonio
{
    public class PruebaPCG : MonoBehaviour
    {
        #region Variables Publicas
        /// &lt;summary&gt;
        /// &lt;para&gt;Semilla.&lt;/para&gt;
        /// &lt;/summary&gt;
        public int seed = 1;                                        // Semilla
        #endregion

        #region Variables Privadas
        /// &lt;summary&gt;
        /// &lt;para&gt;Palabra procesada.&lt;/para&gt;
        /// &lt;/summary&gt;
        private string palabraFinal;                                // Palabra procesada
        /// &lt;summary&gt;
        /// &lt;para&gt;Lista con las letras iniciales.&lt;/para&gt;
        /// &lt;/summary&gt;
        private List&lt;string&gt; letras = new List&lt;string&gt;();           // Lista con las letras iniciales
        #endregion

        #region Inicializadores
        /// &lt;summary&gt;
        /// &lt;para&gt;Cargador de &lt;see cref=&quot;PruebaPCG&quot;/&gt;.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Awake()// Cargador de PruebaPCG
        {
            letras.Add(&quot;P&quot;);
            letras.Add(&quot;R&quot;);
            letras.Add(&quot;O&quot;);
            letras.Add(&quot;C&quot;);
            letras.Add(&quot;E&quot;);
            letras.Add(&quot;D&quot;);
            letras.Add(&quot;U&quot;);
            letras.Add(&quot;R&quot;);
            letras.Add(&quot;A&quot;);
            letras.Add(&quot;L&quot;);
        }

        /// &lt;summary&gt;
        /// &lt;para&gt;Inicializador de &lt;see cref=&quot;PruebaPCG&quot;/&gt;.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Start()// Inicializador de PruebaPCG
        {
            // Inicializamos la semilla
            Random.InitState(seed);

            // Obtenemos la palabra final sin procesar y la mostramos
            for (int n = 0; n &lt; letras.Count; n++)
            {
                palabraFinal += letras[n];
            }
            Debug.Log(&quot;[NORMAL] Palabra inicial: &quot; + palabraFinal);

            // Reseteamos la palabra
            palabraFinal = &quot;&quot;;

            // Procesamos
            while (letras.Count &gt; 0)
            {
                int index = Random.Range(0, letras.Count);
                palabraFinal += letras[index];
                letras.RemoveAt(index);
            }
            Debug.Log(&quot;[FIX] Palabra procesada: &quot; + palabraFinal);
        }
        #endregion
    }
}
</code></pre>

<hr />

<p>Lo primero que debemos haber notado al mirar el código es que tenemos una variable de tipo int que almacena nuestra seed o semilla, que es la que se encargará por supuesto de decidir la secuencia de números que devuelve la clase Random.  Luego se puede observar una variable de tipo string que almacena la palabra final generada por el algoritmo. Y por último una tercera variable que almacena todas las letras de la cadena “HolaMundo” de tipo List almacenando string. En el método Awake ingresamos las letras de la cadena a la lista de manera ordenada, aunque claro está que en este caso el orden no debería influir en lo absoluto más allá de mostrar como era la cadena antes de ser desordenada por la clase Random. Luego en el método Start lo primero que se hace es asignar el seed de nuestra variable al seed de la clase Random, después se recorre con un for la lista de letras y se van ligando a la cadena de la palabra final, para mostrar como era la palabra antes de ser desordenada por consola. Y por último se tiene un while con la condición: mientras queden letras en la lista, y si eso es cierto, entonces se obtiene un índice con la clase Random y el método Range con valores entre 0 y la cantidad de letras (aunque el último valor es exclusivo), posteriormente se concatena a la palabra final la letra que indica el índice obtenido y se quita de la lista de letras la letra ubicada en el índice (esto claro con el objetivo de poder salir en algún momento del ciclo while). Una vez finalizado el ciclo while se imprime por consola la palabra final entregada por nuestra aleatoriedad (especificada por el seed entregado).</p>

<p><center><img src="/img/case/proce003.png" alt="003" /></center>
<center><em>5 resultados distintos del algoritmo, utilizando un seed aleatorio cada vez</em></center></p>

<p>Como podrán darse cuenta las posibilidades son muchas, como para generalas a mano, y con este simple algoritmo ya podemos comprender porque se dice que el PCG es una de las maneras más efectivas para generar mundos completos a partir de un seed, y porque le entrega rejugabilidad a los juegos casi de manera infinita (espero que sus mentes tengan la imaginación suficiente para pensar que cada cadena puede representar un mundo distinto).</p>

<hr />

<h3 id="generando-cuevas">Generando Cuevas</h3>

<p>Pasando ahora a la parte más “compleja” de este post, nuestro objetivo será ahora generar una cueva de manera procedimental, con parámetros que nos permitan entregarle al jugador una solución distinta, y probablemente un mundo distinto cada vez que ejecute el programa. Pero para hacer realidad nuestro sueño dorado, primero debemos comprender un concepto conocido como Cellular Autómata  o en su traducción al español Autómata Celular, que no es más que un modelo computacional discreto (asumo que el lector sabe el significado de discreto en términos matemáticos, y si no es así, espero lo puedan googlear). Los autómatas celulares han sido ampliamente estudiados en la informática, la física e incluso algunas ramas de la biología, como modelos de computación, de crecimiento, de desarrollo, de fenómenos físicos, etc. Pero para su alegría sus conceptos básicos son en realidad muy simples y pueden explicarse en unos pocos párrafos y una imagen o dos. Un autómata celular consiste en una cuadrícula de dimensiones de NxM, un conjunto de estados posibles, y un conjunto de reglas de transición. En esta cuadrícula cada celda puede tomar distintos estados, pero en el caso más simple, puede estar encendida o apagada (tomar un valor 1 o 0). A medida que se realizan iteraciones sobre el autómata este va evolucionando en pasos discretos y siguiendo sus propias reglas. En cada tiempo t, cada celda decide su nuevo estado basado en el estado de sí misma y todas las celdas de su entorno (sus vecinas) en el momento  t-1. Estos vecinos pueden ser tomados en cuenta siguiendo 2 tipos de modelos, que se pueden observar en las siguientes figuras:</p>

<p><center><img src="/img/case/proce004.png" alt="004" /></center>
<center><em>a) Vecinos Moore b) Vecinos von Neumann</em></center></p>

<hr />

<p>En nuestro caso utilizaremos el modelo de Moore, para capturar una celda especifica y aplicar su regla de transición tomando en cuenta los 8 vecinos de la celda actual (celda central C), como veremos más adelante.</p>

<p>Los parámetros que utilizaremos para el control de las cuevas generadas serán:</p>

<ul>
<li>X</li>
<li>Y</li>
<li>Seed</li>
<li>Porcentaje de Muros</li>
<li>Cantidad de iteraciones de suavizado</li>
</ul>

<p>Estos parámetros nos permitirán más o menos mantener un control sobre las cuevas que se generen, y por supuesto replicar las estructuras que encontremos interesantes. Entonces se estarán preguntando pero y cómo realmente generamos las cuevas, y aquí viene lo entretenido, ya que aplicando un autómata celular sobre un algoritmo de randomización veremos como el caos se convierte en algo estructurado. Fíjense en el siguiente código:</p>

<hr />

<pre><code>//                                  ┌∩┐(◣_◢)┌∩┐
//                                                                              \\
// GeneradorMazmorra.cs (26/09/2017)                                            \\
// Autor: Antonio Mateo (Moon Antonio)  antoniomt.moon@gmail.com                \\
// Descripcion:     Generador no logico de mazmorras                            \\
// Fecha Mod:       26/09/2017                                                  \\
// Ultima Mod:      Version Inicial                                             \\
//******************************************************************************\\

#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    /// &lt;summary&gt;
    /// &lt;para&gt;Generador no logico de mazmorras&lt;/para&gt;
    /// &lt;/summary&gt;
    public class GeneradorMazmorra : MonoBehaviour 
    {
        #region Variables Publicas
        /// &lt;summary&gt;
        /// &lt;para&gt;Largo de la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        public int x = 15;                              // Largo de la mazmorra
        /// &lt;summary&gt;
        /// &lt;para&gt;Altura de la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        public int y = 15;                              // Altura de la mazmorra
        /// &lt;summary&gt;
        /// &lt;para&gt;Semilla.&lt;/para&gt;
        /// &lt;/summary&gt;
        public int seed = 99;                           // Semilla
        /// &lt;summary&gt;
        /// &lt;para&gt;Determina si la seed sera aleatoria.&lt;/para&gt;
        /// &lt;/summary&gt;
        public bool seedAleatoria = false;              // Determina si la seed sera aleatoria
        /// &lt;summary&gt;
        /// &lt;para&gt;Porcentaje de muros.&lt;/para&gt;
        /// &lt;/summary&gt;
        [Range(0, 100)] public int Muros = 50;          // Porcentaje de muros
        #endregion

        #region Variabes privadas
        /// &lt;summary&gt;
        /// &lt;para&gt;Mapa de la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        private int[,] mazmorraMapa;                    // Mapa de la mazmorra
        #endregion

        #region Inicializadores
        /// &lt;summary&gt;
        /// &lt;para&gt;Inicializador de &lt;see cref=&quot;GeneradorMazmorra&quot;/&gt;.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Start()// Inicializador de GeneradorMazmorra
        {
            // Creamos la mazmorra
            CrearMazmorra();
        }
        #endregion

        #region Actualizadores
        /// &lt;summary&gt;
        /// &lt;para&gt;Actualizador de &lt;see cref=&quot;GeneradorMazmorra&quot;/&gt;.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Update()// Actualizador de GeneradorMazmorra
        {
            // Creamos la mazmorra
            if (Input.GetMouseButtonDown(0))
            {
                CrearMazmorra();
            }
        }
        #endregion

        #region Metodos
        /// &lt;summary&gt;
        /// &lt;para&gt;Crear la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void CrearMazmorra()// Crear la mazmorra
        {
            mazmorraMapa = new int[x, y];
            Procesar();
        }

        /// &lt;summary&gt;
        /// &lt;para&gt;Logica de la creacion de la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Procesar()// Logica de la creacion de la mazmorra
        {
            Random.InitState((seedAleatoria) ? Random.Range(int.MinValue, int.MaxValue) : seed);

            for (int n = 0; n &lt; x; n++)// Filas
            {
                for (int i = 0; i &lt; y; i++)// Columnas
                {
                    if (n == 0 || n == (x - 1) || i == 0 || i == (y - 1))
                    {
                        mazmorraMapa[n, i] = 1;
                    }
                    else
                    {
                        int probabilidad = Random.Range(0, 100);
                        if (probabilidad &lt; Muros)
                        {
                            mazmorraMapa[n, i] = 1;
                        }
                        else
                        {
                            mazmorraMapa[n, i] = 0;
                        }
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// &lt;para&gt;Dibuja la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void OnDrawGizmos()// Dibuja la mazmorra
        {
            if (mazmorraMapa != null)
            {
                for (int n = 0; n &lt; x; n++)// Filas
                {
                    for (int i = 0; i &lt; y; i++)// Columnas
                    {
                        Gizmos.color = (mazmorraMapa[n, i] == 0) ? Color.white : Color.black;
                        Gizmos.DrawCube(new Vector3(n, i, 0f), new Vector3(0.9f, 0.9f, 0.9f));
                    }
                }
            }
        }
        #endregion
    }
}
</code></pre>

<hr />

<p>Este código simplemente genera caos, como pueden ver en la figura, a pesar de que utiliza algunos de los parámetros que nombré anteriormente, como por ejemplo el seed, el alto, el ancho, e incluso el porcentaje de muros, finalmente solo es capaz de generar caos, ya que no ha sido sometido al autómata celular, es decir, no evoluciona y su forma siempre es el caos, como se puede observar en la figura (los cuadrados o celdas negras representan muros y los blancos suelo, en este caso el porcentaje de muros fue 50%).</p>

<p><center><img src="/img/case/proce005.png" alt="005" /></center>
<center><em>Mapa Aleatoriamente llenado con 0’s y 1’s (50%)</em></center></p>

<hr />

<p>Ahora para solucionar esto simplemente hacemos uso del autómata celular, que como bien dije antes, permitirá hacer evolucionar al mapa de manera tal que una vez aplicadas sus reglas (la de conjugación de vecinos), entonces tomará una forma similar a la de una cueva, en términos de estructura, y el código es el siguiente.</p>

<hr />

<pre><code>//                                  ┌∩┐(◣_◢)┌∩┐
//                                                                              \\
// GeneradorMazmorraLogico.cs (26/09/2017)                                      \\
// Autor: Antonio Mateo (Moon Antonio)  antoniomt.moon@gmail.com                \\
// Descripcion:     Generador logico de mazmorras                               \\
// Fecha Mod:       26/09/2017                                                  \\
// Ultima Mod:      Version Inicial                                             \\
//******************************************************************************\\

#region Librerias
using UnityEngine;
#endregion

namespace MoonAntonio
{
    /// &lt;summary&gt;
    /// &lt;para&gt;Generador logico de mazmorras&lt;/para&gt;
    /// &lt;/summary&gt;
    public class GeneradorMazmorraLogico : MonoBehaviour 
    {
        #region Variables Publicas
        /// &lt;summary&gt;
        /// &lt;para&gt;Largo de la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        public int x = 15;                              // Largo de la mazmorra
        /// &lt;summary&gt;
        /// &lt;para&gt;Altura de la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        public int y = 15;                              // Altura de la mazmorra
        /// &lt;summary&gt;
        /// &lt;para&gt;Semilla.&lt;/para&gt;
        /// &lt;/summary&gt;
        public int seed = 99;                           // Semilla
        /// &lt;summary&gt;
        /// &lt;para&gt;Determina si la seed sera aleatoria.&lt;/para&gt;
        /// &lt;/summary&gt;
        public bool seedAleatoria = false;              // Determina si la seed sera aleatoria
        /// &lt;summary&gt;
        /// &lt;para&gt;Porcentaje de muros.&lt;/para&gt;
        /// &lt;/summary&gt;
        [Range(0, 100)] public int Muros = 50;          // Porcentaje de muros
        /// &lt;summary&gt;
        /// &lt;para&gt;Iteraciones para suavizar la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        public int iteracionesSuavizado = 1;            // Iteraciones para suavizar la mazmorra
        #endregion

        #region Variabes privadas
        /// &lt;summary&gt;
        /// &lt;para&gt;Mapa de la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        private int[,] mazmorraMapa;                    // Mapa de la mazmorra
        #endregion

        #region Inicializadores
        /// &lt;summary&gt;
        /// &lt;para&gt;Inicializador de &lt;see cref=&quot;GeneradorMazmorra&quot;/&gt;.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Start()// Inicializador de GeneradorMazmorra
        {
            // Creamos la mazmorra
            CrearMazmorra();
        }
        #endregion

        #region Actualizadores
        /// &lt;summary&gt;
        /// &lt;para&gt;Actualizador de &lt;see cref=&quot;GeneradorMazmorra&quot;/&gt;.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Update()// Actualizador de GeneradorMazmorra
        {
            // Creamos la mazmorra
            if (Input.GetMouseButtonDown(0))
            {
                CrearMazmorra();
            }
        }
        #endregion

        #region Metodos
        /// &lt;summary&gt;
        /// &lt;para&gt;Crear la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void CrearMazmorra()// Crear la mazmorra
        {
            mazmorraMapa = new int[x, y];
            Procesar();

            for (int n = 0; n &lt; iteracionesSuavizado; n++)
            {
                SuavizarMapa();
            }
        }

        /// &lt;summary&gt;
        /// &lt;para&gt;Logica de la creacion de la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void Procesar()// Logica de la creacion de la mazmorra
        {
            Random.InitState((seedAleatoria) ? Random.Range(int.MinValue, int.MaxValue) : seed);

            for (int n = 0; n &lt; x; n++)// Filas
            {
                for (int i = 0; i &lt; y; i++)// Columnas
                {
                    if (n == 0 || n == (x - 1) || i == 0 || i == (y - 1))
                    {
                        mazmorraMapa[n, i] = 1;
                    }
                    else
                    {
                        int probabilidad = Random.Range(0, 100);
                        if (probabilidad &lt; Muros)
                        {
                            mazmorraMapa[n, i] = 1;
                        }
                        else
                        {
                            mazmorraMapa[n, i] = 0;
                        }
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// &lt;para&gt;Suavizado del mapa.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void SuavizarMapa()// Suavizado del mapa
        {
            for (int n = 0; n &lt; x; n++)
            {
                for (int i = 0; i &lt; y; i++)
                {
                    int cantidadVecinosMuro = GetVecinos(n, i);

                    if (cantidadVecinosMuro &gt; 4)
                    {
                        mazmorraMapa[n, i] = 1;
                    }
                    else
                    {
                        mazmorraMapa[n, i] = 0;
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// &lt;para&gt;Dibuja la mazmorra.&lt;/para&gt;
        /// &lt;/summary&gt;
        private void OnDrawGizmos()// Dibuja la mazmorra
        {
            if (mazmorraMapa != null)
            {
                for (int n = 0; n &lt; x; n++)// Filas
                {
                    for (int i = 0; i &lt; y; i++)// Columnas
                    {
                        Gizmos.color = (mazmorraMapa[n, i] == 0) ? Color.white : Color.black;
                        Gizmos.DrawCube(new Vector3(n, i, 0f), new Vector3(0.9f, 0.9f, 0.9f));
                    }
                }
            }
        }
        #endregion

        #region Funcionalidad
        /// &lt;summary&gt;
        /// &lt;para&gt;Obtiene los vecinos de las coordenadas.&lt;/para&gt;
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;xM&quot;&gt;&lt;/param&gt;
        /// &lt;param name=&quot;yM&quot;&gt;&lt;/param&gt;
        /// &lt;returns&gt;&lt;/returns&gt;
        private int GetVecinos(int xM, int yM)// Obtiene los vecinos de las coordenadas
        {
            int cantidadMuros = 0;
            for (int n = xM - 1; n &lt;= xM + 1; n++)
            {
                for (int i = yM - 1; i &lt;= yM + 1; i++)
                {
                    if (n &gt;= 0 &amp;&amp; n &lt; x &amp;&amp; i &gt;= 0 &amp;&amp; i &lt; y)
                    {
                        if (n != xM || i != yM)
                        {
                            cantidadMuros += mazmorraMapa[n, i];
                        }
                    }
                    else
                    {
                        cantidadMuros++;
                    }
                }
            }
            return cantidadMuros;
        }
        #endregion
    }
}
</code></pre>

<hr />

<p>Lo único que ha cambiado ahora es que el código toma en cuenta la regla de los vecinos,que nos indica que si hay más de 4 vecinos que son muros (es decir más de la mitad del total de 8 vecinos), entonces nuestra celda actual debe convertirse también en muro, por el contrario si son menos de 4 vecinos muros, entonces nuestra celda debe ser un suelo, y solo con esta pequeña modificación y regla ahora nuestro algoritmo arroja resultados como estos, con los mismos parámetros anteriores pero con una cantidad de iteraciones de suavizado igual a 5.</p>

<p><center><img src="/img/case/proce006.png" alt="006" /></center>
<center><em>Algoritmo de Generación de Cuevas</em></center></p>

<hr />

<p>Y ahora piensen en que este resultado es utilizando solo los siguientes parámetros simplemente:</p>

<p><center><img src="/img/case/proce007.png" alt="007" /></center>
<center><em>Parámetros para replicar la cueva anterior</em></center></p>

<hr />

<p>Alcanzan realmente a asimilar lo que esto significa? Si su respuesta es no, entonces los invito a jugar modificando los parámetros para que puedan observar toda la cantidad de diversos resultados que pueden obtener. Y por cierto no sé si se dieron cuenta pero a nuestra seed cada vez que la variable seedAleatoria esta activada, entonces le asignamos un valor aleatorio entre el mínimo número entero posible para el procesador y el máximo (Random.seed = (semillaAleatoria)?Random.Range(int.MinValue,int.MaxValue):semilla;) y si quieren una seed infinita, podrían por qué no utilizar como medida el tiempo actual, que solo fluye hacia adelante como sabemos…</p>

<p><center><img src="/img/case/proce008.gif" alt="008" /></center>
<center><em>Jugando con el algoritmo</em></center></p>

<hr />

<p>Pero no todo es perfecto y si se dan cuenta en realidad nuestra estructura genera en la mayoría de los casos al menos una zona en la que hay solamente suelo, pero que está a si mismo aislada de las demás, por lo que no hay una conexión directa entre las zonas. Para esto por  supuesto existe una solución que por lo demás está más allá del alcance de este post pero que pueden buscar por su cuenta partiendo por algo denominado Flood Fill Algorithm o Algoritmo de relleno por difusión.</p>

<p><center><img src="/img/case/proce009.gif" alt="009" /></center>
<center><em>Algoritmo de relleno por difusión</em></center></p>

<hr />

<p>Este algoritmo puede ser perfectamente utilizado para reconocer todas aquellas zonas que quedaron aisladas de las demás y por supuesto poder conectarlas, claro si que en el caso de conectarlas deberán idear sus propias soluciones o bien recurrir al clásico A* Pathfindinüg Algorithm, pero eso ya es otro cuento, que requiere de un post aparte.</p>

<p><center><img src="/img/case/proce010.gif" alt="010" /></center>
<center><em>A</em> Pathfinding*</center></p>

<hr />

<h3 id="pseudo-conclusiones">Pseudo-Conclusiones</h3>

<p>En fin, espero que este post les pueda servir como una introducción a esta temática tan interesante (me extendí mucho más de lo que debía pero bueno son los gajes del oficio) y que para mi ha sido un área de estudio desde hace algún tiempo atrás. Sin más que decir, esperando que sus cerebros alucinen con tantos bellos algoritmos, de los cuales puedan sacar sus propias conclusiones, me despido de ustedes, y cualquier duda o consulta, ya saben donde la pueden realizar, saludos!</p>

<p>Referencias Bibliográficas:</p>

<p><a href="http://pcgbook.com">Libro académico de papers relacionados con el PCG</a></p>

<p><a href="http://pcg.wikidot.com">Wiki de PCG</a></p>

<p><a href="https://www.packtpub.com/game-development/procedural-content-generation-unity-game-development">Libro sobre PCG en Unity</a></p>

<p><a href="https://unity3d.com/es/learn/tutorials/projects/procedural-cave-generation-tutorial">Generación de Cuevas en 3D con PCG</a></p>

<p><a href="https://gamedevn.wordpress.com">GameDevn</a></p>

<p>.\ Moon</p>


			

			
				<hr>
				

<h3>Relacionado</h3>
<ul>
	
	<li><a href="/post/2017/utiles/012/">La complejidad de la dificultad en un RPG</a></li>
	
	<li><a href="/post/2017/dev/005/">Investigacion RPG-Tactico</a></li>
	
	<li><a href="/post/2017/juegos/003/">Atlus &amp; Europa</a></li>
	
	<li><a href="/post/2017/dev/011/">Comandos de consola Windows</a></li>
	
	<li><a href="/post/2017/dev/010/">Maquina de estados Finitos</a></li>
	
</ul>

			
		</section>
	</article>
	</div>

	<footer class="site-footer">
	<p class="text">&copy; 2020 - Moon Antonio</p>
</footer>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-89564434-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

</body>
</html>
