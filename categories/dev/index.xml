<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>dev - Categoría - N9&#43;</title>
        <link>https://ninpl.com/categories/dev/</link>
        <description>dev - Categoría - N9&#43;</description>
        <generator>Hugo -- gohugo.io</generator><managingEditor>nineplus.n9p@gmail.com (N9&#43;)</managingEditor>
            <webMaster>nineplus.n9p@gmail.com (N9&#43;)</webMaster><lastBuildDate>Wed, 12 Mar 2025 18:18:21 &#43;0100</lastBuildDate><atom:link href="https://ninpl.com/categories/dev/" rel="self" type="application/rss+xml" /><item>
    <title>Renderizar detrás de los iconos del escritorio en Windows</title>
    <link>https://ninpl.com/posts/2025/dev/001/</link>
    <pubDate>Wed, 12 Mar 2025 18:18:21 &#43;0100</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2025/dev/001/</guid>
    <description><![CDATA[Dibuja o renderiza un formulario de Windows directamente sobre el fondo de pantalla, detrás de los íconos del escritorio en Windows.
Introducción Quienes lean este artículo probablemente conozcan DreamScene, la función de Windows Vista que permite renderizar secuencias de vídeo (en formato .dream) como fondo de escritorio. También existe una herramienta llamada Rainmeter que permite colocar widgets, gadgets o cualquier otro elemento en el escritorio, uno encima del otro, arriba y abajo.]]></description>
</item>
<item>
    <title>Orden de ejecución en Unity 6.0</title>
    <link>https://ninpl.com/posts/2024/dev/003/</link>
    <pubDate>Mon, 02 Dec 2024 21:19:04 &#43;0100</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2024/dev/003/</guid>
    <description><![CDATA[Cuando se trabaja con Unity, muchas veces hacer un buen uso de Awake y Start puede ser suficiente como “orden de ejecución” para manejar la inicialización de los sistemas. Por ejemplo, se puede usar Awake para asegurarse de que las referencias locales estén conectadas y luego usar Start para manejar cualquier inicialización coordinada o retrasada que pueda ser necesaria. Esta lección trata realmente sobre lo que se debe hacer cuando esos dos puntos de entrada no son suficientes.]]></description>
</item>
<item>
    <title>Integración de diferentes técnicas de búsqueda de caminos</title>
    <link>https://ninpl.com/posts/2024/dev/002/</link>
    <pubDate>Wed, 10 Jul 2024 17:53:41 &#43;0200</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2024/dev/002/</guid>
    <description><![CDATA[En este documento, exploraremos cómo integrar varias técnicas de búsqueda de caminos. Las técnicas que abordaremos incluyen:
Búsqueda en amplitud (BFS) Búsqueda en profundidad (DFS) Búsqueda de menor costo (Dijkstra) Búsqueda A* (A Star) 1. Búsqueda en Amplitud (BFS) La búsqueda en amplitud explora todos los nodos a una distancia dada antes de avanzar a la siguiente. Es útil para encontrar el camino más corto en un grafo no ponderado.]]></description>
</item>
<item>
    <title>Corrutinas y Async en Unity</title>
    <link>https://ninpl.com/posts/2024/dev/001/</link>
    <pubDate>Sun, 07 Jul 2024 22:33:02 &#43;0200</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2024/dev/001/</guid>
    <description><![CDATA[¿Qué son las Corrutinas? Las corrutinas en Unity son una forma de gestionar la ejecución de código de manera asíncrona, permitiendo pausas en su ejecución y reanudaciones posteriores. Son especialmente útiles para realizar tareas que requieren esperar un cierto tiempo o eventos, sin bloquear el hilo principal del juego.
Características de las Corrutinas Facilidad de uso: Se declaran con el tipo IEnumerator y se controlan usando yield return. Control del tiempo: Permiten pausar la ejecución por un tiempo específico utilizando yield return new WaitForSeconds(tiempo).]]></description>
</item>
<item>
    <title>Uso de GUISkin para el estilo del editor</title>
    <link>https://ninpl.com/posts/2019/dev/004/</link>
    <pubDate>Fri, 03 May 2019 02:02:45 &#43;0200</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2019/dev/004/</guid>
    <description><![CDATA[Al crear ventanas del editor de Unity con barras de herramientas, es posible que haya visto un par de formas diferentes de trabajar con los estilos de la barra de herramientas. Muchos de los ejemplos online o en paquetes de tiendas de activos crean estilos en código que ciertamente funcionan. Sin embargo, no he visto muchos ejemplos usando GUISkin para crear una GUI en el editor, así que pensé en compartir lo que aprendí experimentando con este método.]]></description>
</item>
<item>
    <title>Fases Importantes del desarrollo de un juego</title>
    <link>https://ninpl.com/posts/2019/dev/003/</link>
    <pubDate>Mon, 25 Feb 2019 23:17:23 &#43;0100</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2019/dev/003/</guid>
    <description><![CDATA[Quiero analizar las diferentes etapas que componen la realización de un videojuego profesional. Si estás metido en el mundo del software entonces este proceso te resultará familiar debido a que es muy similar, exceptuando que los videojuegos requieren de grandes aportes creativos.
Fase de Concepción Todo comienza con una idea a partir de la cual se conformarán los aspectos fundamentales. Se determina el género o géneros del videojuego, cómo será el proceso de juego (gameplay), y también se constituye un guion gráfico (storyboard) en el que se tratan todo tipo de ideas preconcebidas que pueden ir adaptándose, como por ejemplo el estilo de los personajes, el ambiente, la música, etc.]]></description>
</item>
<item>
    <title>Shaders Cell Shading (Toon)</title>
    <link>https://ninpl.com/posts/2019/dev/002/</link>
    <pubDate>Tue, 05 Feb 2019 14:38:50 &#43;0100</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2019/dev/002/</guid>
    <description><![CDATA[En post anteriores exploramos cómo podemos cambiar las propiedades físicas para simular diferentes materiales utilizando Surface Shaders. Un modelo de iluminación es responsable de tomar estas propiedades y calcular el tono final de cada píxel.
Comenzaremos con uno realmente simple sobre el que podemos construir, un modelo de iluminación de Lambert. Para ello, debemos saber que es la ley de Lambert.
Ley de Lambert La ley de Lambert trata sobre la iluminancia de una superficie situada a una cierta distancia de una fuente de luz.]]></description>
</item>
<item>
    <title>Personalizando nuestro editor - Unity</title>
    <link>https://ninpl.com/posts/2019/dev/001/</link>
    <pubDate>Thu, 24 Jan 2019 13:28:38 &#43;0100</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2019/dev/001/</guid>
    <description><![CDATA[Un CustomEditor nos permite cambiar la representación visual de nuestras clases en el Unity Inspector. Hace más sencillo interactuar con las script clases asociadas a Gameobjects, prefabs, etc…
. . Nuestro primer paso es crear una carpeta con el nombre Editor. Para Unity es un nombre de carpeta muy especial, Unity carga automáticamente todos los scripts que modifican el comportamiento del UnityEditor desde esta carpeta. Estos scripts NO serán incluidos en el empaquetado final del juego, solo serán usado por el UnityEditor.]]></description>
</item>
<item>
    <title>Shooter Level Design - Conceptos</title>
    <link>https://ninpl.com/posts/2018/dev/015/</link>
    <pubDate>Fri, 30 Nov 2018 15:11:12 &#43;0100</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2018/dev/015/</guid>
    <description><![CDATA[. Un colega esta terminando el TFG de diseño de videojuegos, y el otro dia estuvimos hablando de como crear un entorno para un videojuego shooter, vimos las dificultades y los balanceos necesarios para generar una solución factible y escalable.
Después de unos días de investigación, encontré a un level design que tiene bastante experiencia en este campo, el es Booby Ross, diseñados de niveles de varios juegos de shooter.]]></description>
</item>
<item>
    <title>Ingeniería inversa :: ¿Qué sacar de esto?</title>
    <link>https://ninpl.com/posts/2018/dev/014/</link>
    <pubDate>Sat, 27 Oct 2018 16:15:50 &#43;0200</pubDate>
    <author>N9&#43;</author>
    <guid>https://ninpl.com/posts/2018/dev/014/</guid>
    <description><![CDATA[Llevo unos días profundizando sobre este tema, hasta ahora solo había realizado pequeñas investigaciones sobre esto, pero creo que es algo que puede ayudar mucho tanto para nuevos como para veteranos.
La ingeniería inversa (en inglés, reverse engineering) es el proceso de descubrir los principios tecnológicos de un objeto, herramienta, dispositivo o sistema, mediante el razonamiento abductivo (haciendo conjeturas) de su estructura, función y operación. Dicho de otra manera, se trata de tomar algo, por ejemplo un dispositivo mecánico o electrónico, para analizar su funcionamiento en detalle, con el objetivo de crear un dispositivo que haga la misma tarea o una similar sin copiar los detalles del original.]]></description>
</item>
</channel>
</rss>
