<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lPinchol Moon&#39;s Blog</title>
    <link>http://moonantonio.github.io/categories/git/index.xml</link>
    <description>Recent content on lPinchol Moon&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <copyright>© Antonio Moon.&lt;br&gt;Powered by [Hugo](//gohugo.io/) with the [Type Theme](//github.com/digitalcraftsman/hugo-type-theme)</copyright>
    <atom:link href="http://moonantonio.github.io/categories/git/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Comandos Git Fundamentales</title>
      <link>http://moonantonio.github.io/post/comandos-git-fundamentales/</link>
      <pubDate>Thu, 12 Jan 2017 00:09:45 +0100</pubDate>
      
      <guid>http://moonantonio.github.io/post/comandos-git-fundamentales/</guid>
      <description>

&lt;h1 id=&#34;los-comandos-fundamentales-que-se-usan-en-git&#34;&gt;Los comandos fundamentales que se usan en git.&lt;/h1&gt;

&lt;p&gt;Los comandos fundamentales que se usan en git son muchos, pero dependiendo del tipo de control de versiones que uno esta realizando en ese momento.&lt;/p&gt;

&lt;p&gt;Por ejemplo si estas haciendo un control de versiones de un proyecto en el que solo participas tu, usaras los indispensables ya que con dejar el proyecto abierto para que otros puedas entrar sin problemas de cambiar la config sobra.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;inicializar&#34;&gt;Inicializar:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git init {Crea un nuevo repositorio}
git clone /path/to/repository {Crea una copia local del repositorio}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;registro&#34;&gt;Registro&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git add &amp;lt;filename&amp;gt; {Agrega solo el fichero dado al registro}
git add . {Agrega todos los cambios realizados al registro}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;empaquetado&#34;&gt;Empaquetado&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git commit -m &amp;quot;Mensaje&amp;quot; {Empaqueta el registro para ser mandado}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;envio&#34;&gt;Envio&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git push origin master {Envia el paquete(Commit) por la rama &amp;quot;master&amp;quot; al repositorio}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;ramas&#34;&gt;Ramas&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git checkout -b dev {Crea una rama llamada &amp;quot;dev&amp;quot; y cambiate a ella}
git checkout master {Cambiar de rama}
git branch -d dev {Borra la rama &amp;quot;dev&amp;quot;}
git push origin &amp;lt;branch&amp;gt; {Envia al repositorio la nueva rama para actualizarla a todo el mundo}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;actualizacion&#34;&gt;Actualizacion&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git pull {Descarga los nuevos cambios del repositorio}
git merge &amp;lt;branch&amp;gt; {Fusiona la rama dada con tu rama actual}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;etiquetas&#34;&gt;Etiquetas&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-git&#34;&gt;git tag 1.0.0 {Creas una nueva etiqueta llamada 1.0.0}
git tag 1.0.0 1b2e1d63ff {Creas una nueva etiqueta haciendo referencia a 1b2e1d63ff, que es el id del commit}
git log {Sacas el id del commit}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y eso es todo de momento. Estos son los comandos que mas usaras. Pero si quieres pasar de usar consola y te ves mas comodo con una interfaz grafica, puedes usar diferentes clientes tales como:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://desktop.github.com/&#34; class=&#34;button&#34;&gt;GitHub Desktop(Win &amp;amp; Mac)&lt;/a&gt;&lt;a href=&#34;https://www.sourcetreeapp.com/&#34; class=&#34;button&#34;&gt;SourceTree(Win &amp;amp; Mac)&lt;/a&gt;&lt;a href=&#34;https://www.gitkraken.com/&#34; class=&#34;button&#34;&gt;GitKraken(Win/Mac/Linux)&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chuleta Git Consola</title>
      <link>http://moonantonio.github.io/post/ChuletaGit/</link>
      <pubDate>Thu, 05 Jan 2017 01:02:50 +0100</pubDate>
      
      <guid>http://moonantonio.github.io/post/ChuletaGit/</guid>
      <description>

&lt;h1 id=&#34;chuleta-de-git-consola&#34;&gt;Chuleta de Git (Consola)&lt;/h1&gt;

&lt;p&gt;==============&lt;/p&gt;

&lt;h1 id=&#34;probando-la-consola-y-comandos-para-git&#34;&gt;&amp;gt; Probando la consola y comandos para git&lt;/h1&gt;

&lt;p&gt;##Una vez instalado GIT, se hay que configurar:&lt;/p&gt;

&lt;p&gt;git config &amp;ndash;global user.name &amp;ldquo;&amp;rdquo;
git config &amp;ndash;global user.email &amp;ldquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;##Generando la public key:&lt;/p&gt;

&lt;p&gt;ssh-keygen&lt;/p&gt;

&lt;p&gt;##Leyendo tu llave para copiarla a GitHub&lt;/p&gt;

&lt;p&gt;cat ~/.shh/id_rsa.pub&lt;/p&gt;

&lt;p&gt;##Arrancando tu proyecto:&lt;/p&gt;

&lt;p&gt;git init                        //Iniciar git&lt;/p&gt;

&lt;p&gt;git clone git:ruta github       //Clona un repositorio&lt;/p&gt;

&lt;p&gt;touch README                    //Creas readme&lt;/p&gt;

&lt;p&gt;echo &amp;ldquo;Texto&amp;rdquo; &amp;gt; Readme.md        //Crea un archivo con texto en su interior y se llamara readme.md&lt;/p&gt;

&lt;p&gt;git add README                  //Añades readme&lt;/p&gt;

&lt;p&gt;git status                      //Muestra el estado de git&lt;/p&gt;

&lt;p&gt;git add .                       //Añade todos los archivos&lt;/p&gt;

&lt;p&gt;git commit -m &amp;ldquo;tu primer comm&amp;rdquo;  //Añadir commit&lt;/p&gt;

&lt;p&gt;git remote add origin           //Añadimos el remoto&lt;/p&gt;

&lt;p&gt;git push origin master          //Mandas los commits&lt;/p&gt;

&lt;p&gt;git pull origin master          //Recibir la actualizacion&lt;/p&gt;

&lt;p&gt;git branch                      //Te muestra todas las ramas&lt;/p&gt;

&lt;p&gt;git pull origin master          //Recibir la actualizacion&lt;/p&gt;

&lt;p&gt;git branch dev                  //Creacion de un branch&lt;/p&gt;

&lt;p&gt;git branch -d dev               //Eliminacion de la rama dev&lt;/p&gt;

&lt;p&gt;git checkout dev                //Cambiar a la rama Dev&lt;/p&gt;

&lt;p&gt;gitk                            //Saca la interfaz grafica&lt;/p&gt;

&lt;p&gt;##Todos los comandos:&lt;/p&gt;

&lt;p&gt;Chuleta de comandos git&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* git help &amp;lt;command&amp;gt;
* git clone &amp;lt;uri&amp;gt; namedir # clona usando como nombre de directorio namedir.
* git add &amp;lt;dir&amp;gt; # añade recursivamente todos los archivos del dir.
* git diff --staged # compares staged changes with last commit
* git commit -v # muestra el diff en el editor
* git commit -a -m ” # automatically stage tracked files. No hace falta git add
* git rm --cached &amp;lt;file or regexp&amp;gt; # Git no realiza un seguimiento del archivo, pero los deja en el directorio de trabajo. Útil cuando se olvida añadir archivos al .gitignore y ya hemos agregado dichos archivos al repositorio.
* git rm &amp;lt;file&amp;gt; # borrarlos con git siempre.
* git rm -f &amp;lt;file&amp;gt; # si ya está modificado y en el index.
* git mv &amp;lt;file&amp;gt; &amp;lt;renamed_file&amp;gt;
* gitk # tcl/tk. Herramienta gráfica para git
* git commit --amend # Modificar el mensaje del último commit
* git reset HEAD &amp;lt;file&amp;gt; # to unstage
* git checkout -- &amp;lt;file&amp;gt; # Descartar cambios en el directorio de trabajo.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AÑADIR ARCHIVOS
    * git add -i # interactive staggin
    * git add -p # crea patch&lt;/p&gt;

&lt;p&gt;STASH
    * git stash # guarda el estado en una pila y limpia el directorio para poder cambiar de rama
    * git stash list # muestra la pila
    * git stash apply # vuelve al estado original del dir. Stash{n} especifica uno concreto Y &amp;ndash;index reaplica los cambios stagged
    * git stash pop # elimina el primero en la pila. O drop&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* git log -p -2 # Muestra 2 últimos commits con diff
* git log --stat
* git log --pretty &amp;lt;short|full|fuller&amp;gt;
* git log --pretty=format:”%h - %an, %ar : %s”
* git log --pretty=format;”%h %s” --graph
* git log --since=2.weeks
* git log &amp;lt;branch&amp;gt; --not master # Muestra commit de &amp;lt;branch&amp;gt; sin incluir los de master
* git log --abbrev-commit --pretty=oneline
* git diff master…contrib # Muestra solo el trabajo que la rama contrib actual ha introducido desde su antecesor común con master
* git log &amp;lt;branch1&amp;gt;..&amp;lt;branch2&amp;gt; # Commits de branch2 que no están en branch1
* git log origin/master..master # Muestra qué commits se van a enviar al servidor
* git log origin/master.. # Igual que el anterior. Se asume master o HEAD
* git log refA refB --not refC # commits en refA y refB que no están en refC
* git log master…experiment # commits de master o experiment, pero sin ser comunes. Con --left-right indica a qué rama pertenece cada uno
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;REMOTES # repos en internet
    * git remote -v # lista los repos remotos
    * git remote add [shortname] [url] # crea nuevo remote, es posible descargar el contenido de ese repo con git fetch [shortname]. Master branch en [shortcode]/master
    * git fetch &lt;remote&gt; # descarga trabajo nuevo a máquina local, no sobreescribe nada tuyo. ( git pull sí hace merge automaticamente si se esta realizando un seguimiento de esa branch)
    * git push [remote-name] [branch-name] # sii nadie ha hecho push antes
    * git remote show [remote-name] # inspecciona remote.
    * git remote rename &lt;old-name&gt; &lt;new-name&gt; # también renombra branches: quedaría &lt;new-name&gt;/master
    * git remote rm &lt;remote-name&gt; # p.e si el contribuidor ya no contribuye más&lt;/p&gt;

&lt;p&gt;Añadir varios repositorios remotos
    * git remote add bitbucket git@bitbucket.org:algui91/grado_informatica_tsi_practicas.git # Añadir un nuevo repositorio remoto con el nombre deseado. Por ejemplo si ya tenemos uno en github y queremos añadir otro para bitbucket
    * git push -u bitbucket –all # Subir el proyecto a bitbucket. A partir de ahora se puede seleccionar a qué repo publicar con*git push nombre_repo_remoto&lt;/p&gt;

&lt;p&gt;TAGGINGmarcan puntos importantes en la histtoria del repo ( releases )
    * git tag # muestra las etiquetas actuales
    * git tag -l ‘v1.4.2.*’ # acepta regex
    * Dos tipos de tag:
    * Lightweight : puntero a commit ( branch que no cambia )
    * Annotated : se almacenan como objetos en la db, con checksum, nombre del creador, email, fecha, mensaje, posibilidad de firmarla con GPG. ( recomendada )&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* git tag -a &amp;lt;tagname&amp;gt; -m ‘mensaje’ # annotated tag
* git show &amp;lt;tag-name&amp;gt; # muestra información asociada.
* git tag -s &amp;lt;tag-name&amp;gt; -m ‘message’ # la firma con gpg
* git tag &amp;lt;tag-name&amp;gt; # lightweight tag
* git tag -v &amp;lt;tag-name&amp;gt; # verifica tags firmadas
* git tag -a &amp;lt;tag-name&amp;gt; [commit-chksum] # crea tag para commit con dicho chksum
* Por defecto no se transfieren los tags, para subirlos al servidor:
* git push origin [tag-name] # una sola
* git push origin --tags # Enviar todas

* Para usar GPG y firmar tags, hay que subir la clave pública al repositorio:
* gpg --list-keys # Coges la id pública
* gpg -a --export &amp;lt;id&amp;gt; | git hash-object -w --stdin # Copia el SHA-1 devuelto
* git tag -a maintainer-gpg-pub &amp;lt;SHA-1&amp;gt;
* git push --tags # Comparte la clave con todos los usuarios
* git show maintainer-gpg-pub | gpg --import # Cada usuario importa la clave así
* git show &amp;lt;tag&amp;gt; # Devuelve más información sobre la etiqueta
* git tag -d nombre_tag # eliminar la etiqueta
* git push origin :refs/tags/nombre_tag # Eliminar la etiqueta del repositorio remoto.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;branch&#34;&gt;BRANCH&lt;/h2&gt;

&lt;h1 id=&#34;las-ramas-simplememte-son-punteros-a-distintos-snapshots&#34;&gt;las ramas simplememte son punteros a distintos snapshots&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;* 
    * git branch &amp;lt;nombre-rama&amp;gt; # crea rama. Puntero al commit actual
    * git checkout &amp;lt;nombre-rama&amp;gt; # cambiar a la rama especificada.
    * git checkout -b &amp;lt;nombre-rama&amp;gt; # crea y cambia de rama
    * git merge &amp;lt;rama&amp;gt; # Mezcla la rama actual con &amp;lt;rama&amp;gt;
    * git branch -d &amp;lt;rama&amp;gt; # elimina la rama
    * git push origin --delete &amp;lt;branchName&amp;gt; # Elimina una rama del servidor
    * git mergetool # Herramienta gráfica para resolver conflictos
    * git branch # lista ramas
    * git branch -v # lista ramas mostrando último commit
    * git branch --merged # lista ramas que han sido mezcladas con la actual. Si no tienen un *, pueden borrarse, ya que significa que se han incorporado los cambios en la rama actual.
    * git branch --no-merged # lista ramas que no han sido incorporadas a la actual. ## REMOTE BRANCHES

    * git fetch origin # Descarga el contenido del servidor
    * git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt; # Las ramas no se suben por defecto, has de subirlas explícitamente
    * git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;:&amp;lt;nuevoNombre&amp;gt; # Igual que la de arriba, pero en el servidor se llama a la rama con nuevoNombre en lugar de branch
    * Cuando se hace un git fetch que trae consigo nuevas ramas remotas, no se disponen de ellas localmente, solo se dispone de un puntero a la rama remota que no es editable. Para poder trabajar sobre esa rama, es necesario crearla Por ejemplo:
    * git fetch origin # Tras ejecutarlo, notamos que se ha creado una rama nueva (rama_nueva)
    * git checkout -b rama_nueva origin/rama_nueva # Crea una rama local a partir de la remota
    * git merge origin/nueva_rama # Equivalente a la de arriba, pero sin establecer el tracking a la rama

    * git push [remotename] :[branch] # elimina una rama remota
    * **git push [remotename] [localbranch]:[remotebranch] ** # La rama en el servidor tiene distinto nombre a la local ## TRACKING BRANCHES

    * git checkout --track origin/rama # Equivalente a -b rama_nueva origin/rama_nueva
    * git chekout -b &amp;lt;nuevo_nombre&amp;gt; origin/&amp;lt;rama&amp;gt; # Establece un nombre distinto para la rama local ## REBASE

* Rebase y merge se diferencian en que merge mezcla dos puntos finales de dos snapshots y rebase aplica cada uno de los cambios a la rama en la que se hace el rebase. No lo uses en repos publicos con mas colaboradores, porque todos los demas tendrán que hacer re-merges

* 
    * git checkout &amp;lt;una rama&amp;gt;
    * git rebase master # aplica todos los cambios de &amp;lt;una rama&amp;gt; a master
    * git merge master # hay que hacer un merge de tipo fast forward
    * Tenemos 3 ramas, master, client y server, en server y client tenemos varios commit y queremos mezclar client en master pero dejar server intacta:
    * git rebase --onto master server client # adivina los patches del antecesor común de las ramas server y client y aplica los cambios a master.
    * git checkout master*
    * git merge client # fast-forward. Client y master en el mismo snapshot
    * Si se quiere aplicar también los cambios de server, basta con:
    * git rebase master server*
    * git checkout master*
    * git merge server*

    * git rebase [basebranch] [topicbranch] # sintaxis de rebase
    * git rebase -i # Rebase interactivo

* # SERVIDOR

* 
    * git instawew # Muestra una interfaz web con los commits ## GENERAR UN NÚMERO DE COMPILACIÓN (BUILD NUMBER)

    * git describe master # Solo funciona para tags creadas con -s ó -a ## PREPARAR UNA RELEASE

    * git archive master -- prefix=”project/’ | gzip &amp;gt; `git describe master`.tar.gz

    * 
        * git archive master -- prefix=”project/’ --format=zip | `git describe master`.zip
        * test/ export-ignore # Al crear el tarball no incluye el directorio test/

    * ## GENERAR UN CHANGELOG

    * 
        * git shortlog --no-merges master --not &amp;lt;tag&amp;gt; # Recopila todos los commits desde &amp;lt;tag&amp;gt; y los agrupa por autor

    * ## RECOMENDACIONES

    * 
        * Siempre hay que hacer pull antes de push en caso de que alguien haya subido cambios al servidor. Ejemplo:
        * User1 clona el repo y hace cambios, realiza un commit
        * User2 clona el repo, hace cambios, hace commit y sube los cambios con push
        * User1 intenta hacer push, pero será rechazado con: &amp;lt;u&amp;gt;! [rejected] master -&amp;gt; master (non-fast forward)&amp;lt;/u&amp;gt;. No puede subir los cambios hasta que no mezcle el trabajo que ha subido User2. Así que debe hacer lo siguiente:

        * git fetch origin
        * git merge origin/master
        * git push origin master

        * Mientras User1 hacía estas operaciones, User2 ha creado una rama &amp;lt;u&amp;gt;issue54&amp;lt;/u&amp;gt; y realizado 3 commits, sin haber descargado los cambios de User1. Para sincronizar el trabajo, User2 debe hacer:
        * git fetch origin
        * git log --no-merges origin/master ^issue54 # Observa qué cambios ha hecho User1
        * git checkout master
        * git merge issue54 &amp;amp;&amp;amp; git merge origin/master*
        * git push origin master*

        * git diff --check # Antes de hacer commit, ejecutar esto para ver si hemos añadido demasiados espacios que puedan causar problemas a los demás.
        * Commits pequeños que se centren en resolver un problema, no commits con grandes cambios.
        * git add --patch # En caso de hacer varios cambios en el mismo archivo
        * El mensaje del commit debe tener la estructura siguiente: Una linea de no más de 50 caracteres, seguida de otra línea en blanco seguida de una descripción completa del commit.

    * ## PASOS A SEGUIR PARA CONTRIBUIR A PROYECYOS AJENOS, MEDIANTE FORK

    * 
        * git clone &amp;lt;url&amp;gt;
        * git checkout -b featureA
        * git commit
        * git remote add myFork &amp;lt;url&amp;gt;
        * git push myFork featureA
        * git request-pull origin/master myFork # enviar la salida por mail al propietario del proyecto, o hacer click en pull request.
        * Buena practica tener siempre una rama master que apunte a origin/master, para estar siempre actualizado con los ultimos cambios en el proyecto original.
        * Separar cada trabajo realizado en topic branch, que trackeen a origin/master

        * git checkout -b featureB origin/master
        * (Hacer cambios)
        * git commit
        * git push myFork featureB
        * (Contactar con el propietario del proyecto)
        * git fetch origin

        * Otro ejemplo, el propietario del proyecto quiere aceptar un pull tuyo, pero quiere que hagas algunos cambios, aprovechas la oportunidad y mueves tu trabajo para basarlo en el contenido actual de la rama origin/master, aplastas los cambios enfeatureB, resuelves conflictos, y haces push:

        * git checkout -b featureBv2 origin/master
        * git merge --no-commit --squash featureB
        * (cambiar la implementacion)
        * git commit
        * git push myFork featureBv2

        * --squash coge todo el trabajo de la rama mezclada y la aplasta en un no-merge commit encima de la rama en la que estas. --no-commit no registra el commit automaticamente. Así puedes realizar todos los cambios necesarios y luego hacer el commit

    * En segundo plano, git crea un log de a donde han estado referenciando HEAD y el resto de ramas en los últimos meses.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reflog&#34;&gt;REFLOG&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;    * 
        * git reflog*
        * **git show HEAD@{n} ** # Muestra información sobre el reflog número n
        * git log -g master # Muestra el log formateado como la salida de reflog
        * **git show master@{yesterday} ** # Muestra los commits de ayer.

    * ## UTILIDADES

    * 
        * git show &amp;lt;short-SHA-1&amp;gt; # Es posible ver un commit pasando la versión abreviada del SHA-1
        * git rev-parse &amp;lt;branch&amp;gt; # A qué SHA-1 apunta una rama
        * **git show HEAD^ ** # Muestra commit padre
        * git show HEAD^2 # Muestra segundo padre
        * git show HEAD~2 # El primer padre del primer padre
        * git filter-branch --tree-filter ‘rm -f &amp;lt;file&amp;gt;’ HEAD # elimina el archivo de todos los commits

    * ## DEPURACIÓN

    * 
        * File anotation
        * git blame -L 12,22 &amp;lt;archivo&amp;gt; # muestra cuando y por quién se modificaron de la linea 12 a la 22
        * git blame -C -L 141,153 &amp;lt;file&amp;gt; # cuando renombras un archivo o lo refactorizas en varios, muestra de donde vino originalmente.

        * Búsqueda Binaria: Cuando hay un bug que no puedes localizar, usas bisect para dererminar en qué commit empezó a producirse el bug.
        * git bisect start*
        * git bisect bad # marcas el commit actual como roto
        * **git bisect good [commit bueno] ** # último commit conocido que funcionaba
        * Ahora irá preguntando hasta que encuentres el commit culpable. Si esta bien indicas git bisect good. De lo contrario git bisect bad. Al terminar hay que resetear.
        * git bisect reset

    * ## SUBMODULOS

    * 
        * git submodule add &amp;lt;url&amp;gt; # crea un directorio que contiene el comtenido de otro proyecto.

        * Clonar un repo con submodulos
        * git clone url
        * git submodule init
        * git submodule update

    * ## CONFIGURATION

    * 
        * git config --global &amp;lt;opcion&amp;gt; &amp;lt;valor&amp;gt; # global para usuario, system todos y sin nada, especifico para el repo.
        * **git config {key} ** # muestra el valor de key
        * git config --global core.editor &amp;lt;editor&amp;gt; # cambia el editor por defecto
        * git config --global commit.template $HOME/.gitmessage.txt # plantilla para commits
        * **git config --global core.pager ‘moreless’** # paginador por defecto, puedes usar cualquiera
        * git config --global user.signingkey &amp;lt;gpg-key-id&amp;gt; # clave gpg para firmar tags
        * git config --global core.excludesfile &amp;lt;file&amp;gt; # como gitignore
        * git config --global help.autocorrect 1 # autocorrige cuando se escribe un comando incorrecto. Solo en git &amp;gt;= 1.6.1
        * git config --global color.ui true # colorea la salida de git. Valores: truefalsealways
        * git config --global core.autocrlf input # para que usuarios linux no tengan problemas con los retornos de carro de windows
        * git config --global core.autocrlf true # para usuarios de windows
        * git config --global core.whitespace trailing-space, space-before-tab, indent-with-non-tab, cr-at-eol # respectivamente: busca espacios al final de línea, busca espacios al inicio de tabulación, busca líneas con 8 o más espacios en lugar de tabulaciones, acepta retornos de carro
        * git apply --whitespace=warn &amp;lt;patch&amp;gt; # advierte de errores de espacios antes de aplicar el patch. Con --whitespace=fix intenta arreglarlos

    * Otro ejemplo interesante es la expansión de la palabra clave$Date$. Para ello hay que escribir un script en ruby que recibe un archivo, encuentra la fecha de su último commit e inserta dicha fecha en el archivo:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;git config &amp;ndash;global filter.indent.smudge cat
git config &amp;ndash;global filter.indent.clean indent
&lt;em&gt;.c filter=indentLuego:
Procesar archivos antes de hacer commit y antes de hacer checkout: Es posible crear tus propios filtros para hacer sustitución. Estos filtros se llamansmudgeyclean. Los puedes configurar para distintos directorios y luego escribir un script que procesará cada archivo antes de que sea checkeado (smudge) y commiteado (clean). Para ello,escribe en el .gitattributes: (En caso que quieras procesar código C)
Es posible hacer lo mismo para imágenes jpeg, es necesario instalarexiftoolpara extraer los metadatos y luego hacer:
echo ‘&lt;/em&gt;.jpeg diff=exif’ » .gitattributes
git config diff.exif.textconv exiftool
Diffing binary files
En ocasiones es útil mostrar diffs de archivos binarios, como una archivo de word:
*.doc diff=word
#tras esto hay que definir el filtro word para que git convierta archivos word a texto:
git config diff.word.textconv strings
Identificando archivos binarios
Muchos archivos son para uso local y no aportan información al repositorio. Para decirle a git qué archivos son binarios hacer añadir al archivo atributes:
&lt;nombre archivo o regexp&gt; -crlf -diff # git no intentará corregir problemas de crlf ni mostrará los cambios con diff. En versiones &amp;gt;= 1.6 se pueden sustituir estos dos valores por la macro binary
Archivo en .gitattributes en el directorio de trabajo o en .git/info/attributes para no committearlo&lt;/p&gt;

&lt;h2 id=&#34;git-attributes&#34;&gt;GIT ATTRIBUTES&lt;/h2&gt;

&lt;p&gt;#! /usr/bin/env ruby
  STDIN
last_date  &lt;code&gt;git log --pretty=format:&amp;quot;%ad&amp;quot; -1&lt;/code&gt;
 &amp;lsquo;$Date$&amp;rsquo; &amp;lsquo;$Date: &amp;lsquo;  last_date&lt;br /&gt;
Puedes nombrar este script comoexpand_date. Crea un filtro en git, llamado dater y dile que use el script anterior:
git config filter.dater.smudge expand_date
git config filter.dater.clean ‘perl -pe “s/\$Date[^\$]*\$/\$Date\$/”‘
Para usar el filtro, simplemente escribe la palabra clave en los archivos que desees:
*echo ‘# $Date$’ &amp;gt; date_test.txt
echo ‘date.txt filter=dater’ » .gitattributes
git add date_test.txt .gitattributes
git commit -m “Testing date expansion in Git”
rm date_test.txt
git checkout date_test.txt
cat date_test.txt
$Date: Tue Apr 21 07:26:52 2009 -0700$&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>